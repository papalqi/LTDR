##共有派生

##私有派生
派生类需要自己的构造函数
派生类根据需要添加额外的数据成员和成员函数
派 
如果省略初始化列表，程序将使用默认的基类构造函数。除非使用默认的构造函数，否则应该显示的调用正确的基类构造函数。
基类指针可以在不进行显式类型转换的情况下指向派生类对象，基类引用可以在不进行显式类型转换的情况下引用派生对象。
通常c++要求引用和指针类型与赋予的类型匹配，但这一规则对继承来说是个例外。
--------------------------------------------------------------------------------
共有继承，保护继承，私有继承
公有继承：是is-a-kind-of
而不是 have-a； is-like-a； is-implemented-as-a；uses-a
##多态共有继承
即同一个方法的行为是随上下文而异，有两种重要的机制可用于实现多态共有继承：
在派生类中重新定义基类方法
使用虚方法
如果方法是用过引用或者指针而不是对象调用的，它将确定使用哪一种方法，如果没有使用关键字virtual程序将根据引用类型或指针类型选择方法，如果使用了virtual，程序将根据引用或指针指向的对象的类型来选择方法。
基类中被声明为虚函数后，他在派生类中将自动成为虚方法
基类声明一个虚的析构函数，这样做的目的是确保释放派生对象时，按正确的顺序调用析构函数。
使用虚方法的情景之一就是用一个基类的数组存储两个不同的类指针
--------------------------------------------------------------------------------
##静态联编和动态联编
在编译时选择正确方法的是静态，又叫早期联编。在运行时选择正确的虚方法的代码称之为动态联编，又称为晚期联编。
隐式向上强制转换使得基类指针或者引用可以指向基类或者派生类。
为什么有两种类型的联编以及为什么默认为静态？不要为不使用的特性付出代价。
虚函数的工作原理。
有关虚函数的注意事项：
在基类中使用virtual使得派生类都是virtual。
###动态联编。
如果定义的类将被用作基类。则应将哪些要在派生类中重新定义的类方法声明为虚的
友元函数不能是虚函数，只有成员才能使虚函数。
没有重新定义的函数，将使用该函数的基类版本。如果派生类位于派生链中，则将使用最新的虚析构函数版本，例外的情况是基类版本是隐藏的。
重新定义将隐藏方法。放回类型协变，只适用于返回值而不能是参数。如果基类声明被重载了，则应该在派生类中重新定义所有的积累版本
？？？？？
--------------------------------------------------------------------------------
##访问控制
对于数据成员来说，尽量不要用protected，因为这会让数据在派生类中当成一个共有成员来用。
而对于成员函数来说，保护访问控制很有用，它让派生类能够访问公众不能使用的内部函数
##抽象基类
纯虚函数提供为实现的函数，纯虚函数的声明结尾处为 =0；
##继承和动态内存分配
####第一种情况：派生类不使用new
如果派生类不包含一些不常用的需要特殊处理的设计特性，那么
并不需要析构函数，默认的就可以。因为派生类的默认析构函数总是要进行一些操作：执行自身的代码后调用基类的析构函数
并不需要复制构造函数，派生类的默认构造函数使用显式的基类的复制构造函数来复制基类部分。对于赋值也是如此。
####第二种：派生类使用new
1.派生类析构函数自动调用基类析构函数，故自身的职责是对派生类构造函数进行清理。
2.复制构造函数，需要调用基类的复制后遭函数来处理共享的数据。用初始化列表    ，引用传递一个派生类的对象，而基类的复制构造函数将使用对象的基类部分进行构造。
3.赋值运算符，需要一个显式的赋值运算符，派生类无法访问基类数据，所以可以通过显示调用基类的赋值运算符，例如
base::operator=（hs）；//函数标识符
*this=hs；//错误，会形成递归
使用动态内存分配和友元的实例
当使用友元函数时，我们需要解决的问题是：因为友元函数不是成员函数，能访问派生类，不能访问基类，需要用基类的友元函数。还有一个问题是调用的是哪一个函数，因为不能使用作用域运算符来指出使用哪个函数，所以使用强制类型转换。
###类设计回顾
####编译器生成的成员函数
默认构造函数
复制构造函数
赋值运算符
####其他的类方法
构造函数
析构函数
转换
当一个构造函数只有一个参数，而且该参数又不是本类的const引用时，这种构造函数称	为转换构造函数。
系统将自动调用这个函数，当然用户也可以自己调用。
按值传递对象与传递引用
返回对象和返回引用
使用const、
###公有继承的考虑因素
1.is-a关系
2.为什么不能被继承
3.赋值运算符
将派生类对象赋值给基类对象将会如何，这是可行的，但这只涉及基类成员。
反过来是不行的，除非有转换构造函数。或者是定义一个将基类赋值给派生类的赋值运算符。
4.私有成员与保护成员
5.虚方法
6.析构函数
7.友元函数
8.有关使用基类方法的说明
类函数小结