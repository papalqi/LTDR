1.动态内存和类
##1.复习静态类成员
静态类是指无论创建了多少个对象，程序都只创建一个静态变量副本。用static
对于静态类成员，可以在类声明之外使用单独的语句来进行初始化，静态类成员是单独存储的，不是对象的组成部分。
一般而言，初始化时在方法文件而不是在声明文件，因为在头文件初始化，会出现多个初始化语句副本，从而引发错误。
ps：如果静态成员是const整数类型或者枚举类型，则可以在类声明中初始化。
当用一个对象初始化另一个对象时：string sail=sport；
编译器自动生成string sail=string（sport）构造函数，称为复制构造函数。
--------------------------------------------------------------------------------
##c++自动提供下面的成员函数
1.默认构造函数（如果没有定义）
2.默认析构函数（如果没有定义）
3.复制构造函数（如果没有定义）
4.赋值运算符（如果没有定义）
5.地址运算符（如果没有定义）
ps：还有另外两个特殊的成员函数：移动构造函数和移动赋值运算符。move construtor move operator
###1.默认的构造函数：
带参数的构造函数也可以是默认构造函数，只要所有参数都有默认值
###2.复制构造函数
用于将一个对象复制到新创建的对象中。class_name(const class_name&);
每当程序生成了对象副本时，编译器都将使用复制构造函数：
具体，当函数按值传递对象或者函数返回对象时。
编译器生成临时副本时，也将使用复制构造函数。
所以我们应该尽量使用引用传递传递对象，可以节省调用构造函数的时间以及存储对象的				      		空间。
深度复制：不是将指针赋值，而是将副本的地址赋值给其他的对象。
如果类中包含了使用new初始化的指针成员，应当定义一个复制构造函数，以复制指向的数据，而不是指针，这是称为深度复制。是
###3.赋值运算符：

自动为类重载赋值运算符。class_name &class_name::operator =(const class_name&);
初始化对象时，并不一定使用赋值运算符。
初始化总是会调用复制构造函数，而使用=运算符时也允许调用赋值运算符 
delete[] 与new[]和空指针兼容，对于以其他方式初始化的指针，使用delete[]效果是不确定的。

在c++98中 0表示数值0也可以表示空指针 nullptr （void*）0 NULL
如果const string a；a[1];必须重载const char &string：：operator（int i）const

静态类成员函数
静态成员函数不能通过对象调用静态成员函数，实际上，实际上甚至不能使用this指针，并且只能使用静态数据成员
包含类成员的类的逐成员复制，默认的逐成员复制和赋值行为有一定的智能。如果类因为其他的成员需要定义复制构造函数，情况将更复杂。这些东西将在第13章讨论
--------------------------------------------------------------------------------
##有关返回对象的说明
1.返回指向const对象的引用
2.返回指向非const对象的引用
3.返回对象
4.返回const对象

再谈new 和delete 有定位的new
--------------------------------------------------------------------------------
##类的初始化
在类中可以定义只在类中使用的结构体或者类。
const常量可以对它初始化但是不能给它赋值。因为对象将在括号中的代码执行之前被创建，所以会先给成员分配内存，然后，才运行构造函数。
所以对于const数据成员，必须在执行到构造函数体之前，即创建对象时进行初始化。这种方法是初始化列表。并且只有构造函数可以使用这个语法。
对于const和引用都要使用初始化列表，因为引用和const是类似的。只能在创建的时候进行初始化。
对于本身就是类对象的成员来说，使用成员初始化列表的效率更高。我们将在第14章进行讲解。