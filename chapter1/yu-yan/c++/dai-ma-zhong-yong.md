##包含对象成员的类
用于实现has-a的关系
###    valarray类简介
valarray<int> q_values
可以使用初始化列表 valarray<int>v5={20,32,20,5,1}(c++)
###student类设计
typedef ,在编译阶段出现错误优于在运行阶段出现错误。
初始化被包含的对象
1.如果不使用初始化列表，c++要求在构造对象其他的部分之前，先构造继承对象的所有
成员对象？？？？？？
2.初始化的顺序，项目被初始化的顺序为他们被声明的顺序，而不是他们在初始化列表的
中的顺序。如果一个成员的值作为另一个成员初始化表达式的一部分，顺序就格外重要。
使用被包含对象的接口
使用新的student
##私有继承
另一种实现has-a的途径就是私有继承。基类的公有成员和保护成员都将成为派生类的私有成		  员，这意味着基类方法不会成为派生对象共有接口的一部分，但可以在派生类的成员函数中使用它。
我们用术语subobject子对象来表示通过继承或包含添加的对象。，
包含版本提供两个被显示命名的对象成员。而私有继承提供了两个无名称的子对象成员。
对于继承类，将使用成员初始化列表语法，他使用类名而不是成员名称。
2.访问基类的方法，将使用作用域解析运算符来调用方法。
3.访问基类对象,要返回对象的技巧是使用强制类型转换 return（const string&）*this
4.访问基类的友元函数：在私有继承中，未进行显式类型转换的派生类引用或指针，无法赋值给基类的引用或指针。就算是公有继承，也不行，因为递归和二义性，不知道转化成哪一个（因为使用了多重继承）

保护继承，将共有和保护成员都变成保护
使用using重新定义访问权限：using std::valarray<double>::sum;
--------------------------------------------------------------------------------
##多重继承
使用多个基类的继承成为多重继承（multiple inheritance MI）。通常MI尤其是共有的MI将导致一些问题，必须用额外的语法规则来解决他们。
主要问题有两个：
1.两个不同基类继承同名方法
2.从两个或更多相关基类那里继承同一个类的多个实例。
c++引入多重继承的 同时，引入了一种新技术——虚基类（virtual base class）使得MI成为可能
###1.虚基类
为什么使用术语虚，因为关键字重载。
为什么不抛弃基类声明为虚的这种方法，而使得虚行为成为多MI准则
1.在一些情况下，可能需要基类多个拷贝。
2.将积累作为虚的要求程序有额外的计算，位不需要的工具付出代价是不应当的，
3.这样做是有缺点的。
是否存在麻烦
是的，需要对c++规则进行调整，必须以不同的方式编写一些代码
###2.新的构造函数规则
使用虚基类时，需要对类构造函数采用一种新的方法。
对于非虚基类，唯一可以出现在初始化列表中的构造函数是及时基类构造函数。
如果使用的是虚基类，则这种信息自动传递将不起作用。编译器将使用基类的默认构造函数。如果不希望默认构造函数的话，则需要显式地调用所需的基类构造函数。因此构造函数应该是显示的调用虚基类的构造函数。
哪个方法
如果没有重新定义，则需要使用最近祖先中的定义，而在多重继承中，每个直接祖先都有一个show，这就使得有二义性，
##类模板
###定义类模板
模板类用这个开头：template<class Type>
template<typename Type>
模板不能放在单独的文件实现当中而是要将所有的模板信息放在一个头文件中，因为不能单独编译。
一般就是使用内联定义，这样可以省略模板前缀和类限定符。
例子：template<typename Type> bool stack<Type>::push();

###使用模板类
使用模板必须请求实例化。方法是使用所需的具体类型替换泛型名。stack<int> k;
深入讨论类模板
不正确的使用指针栈（切记不要盲目的使用指针栈）
仅仅创建指针，没有创建用于保存输入字符串的空间
与类方法不兼容
使用new方法建立的变量总是指向一个特定的空间
正确使用指针栈
1.让调用程序提供一个指针数组，其中每个指针都指向不同的字符串。

###数组模板示例和非类型参数
模板常用作容器类，因为类型参数的概念非常适合于将相同的存储方案用于不同的类型。
允许制定数组大小的简单数组模板。
1.使用动态数组和构造函数参数。
2.使用模板参数来提供常规数组大小。
template<double ,12>
template<class T,int n>,称为非类型或者表达式参数。
表达式参数：表达式参数可以是枚举，整形，引用，指针。
模板代码不能修改参数的值，也不能使用参数的地址。另外，用作参数的值必须是常量表达式。
但是表达式方法的主要缺点是：每种数组大小都将生成自己的模板。
构造函数的方法更为通用。数组的大小是作为类成员存储在定义中的。这样可以将一种尺寸的数组赋给另一种尺寸的数组，也可以创建数组大小可变的类。
###模板多功能性
可以使用常规技术用于模板类，模板类可用作基类，也可用于组件类，还可以用作其他模板的类型参数。
在模板语法中，维的顺序与等价的二维数组相反。
使用多个类型参数
默认类型模板参数
虽然可以为类模板类型参数提供默认值，但不能为函数模板参数提供默认值。然而可以为非类型参数提供默认值。这对于类模板和函数模板都是试用的。
###模板具体化
####隐式实例化
####显式实例化
template class arraytp<string，100>；
####显式具体化
显式具体化是特定类型的定义。有时候可能需要在为特殊类型实例化时，对模板进行修改，使其行为不同，在这种情况下，可以进行显式的具体化。
当具体化模板和通用模板都与实例化请求匹配时，编译器使用具体化版本。
template<>classname<specialized-tpye-name>{};
####部分具体化
部分限制模板的通用性。template<class T1>class pair<T1,int>
template<>class pair<int,int>{};
如果有多个模板可供选择，编译器将使用具体化程度最高的模板。
template<class T>  template<class T*>
提供指针版本。
部分具体化使得能够设置各种特性。
###成员模板
模板可用作结构、类或模板类的成员。
一些编译器根本不接受模板成员，而另一些编译器接受模板成员，但不接受外面的定义。如果接受外面定义的话（P586）
###    将模板用作参数
模板可以包含本身就是模板的参数。这种参数是模板新增的特性。
###模板类和友元
非模板友元函数
这个类每一个类的每一个特定的具体化都将有自己的静态成员。
约束模板友元，即友元的类型取决于类被实例化时的类型
必须满足三个要求：
首先在定义前面声明每个模板函数，函数中再次将模板声明为友元，为友元提供模板定义。
如果有参数的话，可以从参数类型推断出要使用的具体化，
非约束模板友元，即友元的所有具体化都是类的每一个具体化的友元
what's the meaing
###模板别名
typedef std::array<double,12> arrd;
可用模板提供一系列别名template<typename T>
using arrtype=std::array<T,12>;
arrtype <double> gallons
可变参数模板。
总结