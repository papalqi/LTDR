# 类型定义

## struct

* 声明结构体（除了模板和访问权限有区别，其它情况和类差不多）
* 在枚举当中使用，限定范围
* 消除歧义

## union

* union是一种特殊的类类型，一次只能包含一个非静态数据成员。
* 匿名union,它们不能拥有成员函数，不能拥有静态数据成员，并且所有数据成员都必须是公共的。允许的唯一声明是非静态数据成员和static\_assert声明 。

## enum

* 分为无范围的枚举，范围内的枚举。主要是使用enum class（自C ++ 11以来），或enum struct（自C ++ 11以来）来区分。

## class

* 类，具体参见其他章节

## typedef

* 创建一个可以在任何地方使用的别名来代替（可能是复杂的）类型名称

# 类型限定

## volatile[^1]

* 被设计用来修饰被不同线程访问和修改的变量。在程序设计中，尤其是在C语言、C++、C\#和Java语言中，使用volatile关键字声明的变量或对象通常拥有和优化和（或）多线程相关的特殊属性。如果没有volatile，基本上会导致这样的结果：要么无法编写多线程程序，要么编译器失去大量优化的机会。
* volatile本意为“易变的”，针对其的任何赋值或者获取值操作都会被执行（而不会被优化）。由于这个特性，所以该关键字在嵌入式编译环境中经常用来消除compiler的优化。volatile的含义就是明确告诉编译器，这个变量在每次访问时，都走内存，而不要用寄存器来缓存。这样在抢占式多任务里，就能确保每次拿到最新的值。而register的意思则相反，告诉编译器这个变量尽可能放到寄存器里，以提高速度。当然如果寄存器不够用，那就还是放内存里。
* 实际使用中，如果一个变量仅在函数内使用，或作为值传递的形参，那么适合使用register修饰符。而如果是全局变量，且可能被多人任务读写，则应该明确的使用volatile。比如中断中访问的全局变量，就应该用volatile。 
* **也就是说**：
  * * 告诉compiler不能做任何优化
  * * 表示用volatile定义的变量会在程序外被改变,每次都必须从内存中读取，而不能把他放在cache或寄存器中重复使用。
  
所以现在应该是用不到。
## const

* 类型为 const限定的对象，或const对象的不可变子对象。无法修改此类对象：尝试直接执行此操作是编译时错误，并尝试间接执行此操作（例如，通过引用或指向非const类型的指针修改const对象）会导致未定义的行为

## restrict



  


  




[^1]: 一个函数在执行时会使用多个局部变量，包括形参。这些变量使用频度差异较大，编译器会按照使用频度来规划，将常用变量放到闲置寄存器里，使得运算速度得到很大的提高。不常用的那些就放内存里，每次用到就去内存里拿。一个值存放在寄存器和内存里，访问速度的差别可达数百倍甚至上千倍。可见将变量放在寄存器里的意义还是很大的。

