##友元
###友元类
类友元是一种自然用语，用于表示一些关系。
###友元成员函数
可以选择让特定的类成员成为另一个类的友元，而不必让整个泪成为友元。
###其他友元关系
互为友元，这里要注意的就是声明的顺序
###共同的友元
两个类共同的友元函数
##嵌套类：
将类的声明放在另一个类中，如果不在声明中定义，则需要使用两次作用域解析运算符来完成嵌套类的访问权限
在私有部分：只有上部知道
在保护部分：派生类知道嵌套类，并可以直接创建这种类型的对象。
在共有部分：使用作用域解析运算符。（很多程序员都使用共有枚举来提供可供客户户程序员使用的类常数  ）
模板中的嵌套

##异常
c++异常为处理这种情况提供了一种功能强大而灵活的工具，编译器是默认关闭这种特性的，需要使用编译器选项来启动它。
###调用abort（）
cstdlib\stdlib.h,向标准错误流发送信息，然后终止程序。然而依靠程序员来执行这种检查是不安全的。
###返回错误码

###异常机制
对于异常处理一般来说有三个部分组成
1.引发异常
2.使用处理程序捕获异常
3.使用try块
catch来捕捉异常，
###将对象用作异常类型
###异常规范和c++11
最好不要使用异常规范，使用新增的关键字noexcept指出函数不回引发异常，
###栈解退
控制权将转到块尾单异常处理程序，而不是函数调用后面的第一条语句。
假设函数由于出现异常而终止，则程序也将释放栈中的内存，但不会在释放栈道第一个返回地址后停止，而是继续释放栈，直到找到一个位于try块中的返回地址。
###其他异常特性
引发异常时编译器总是创建一个临时拷贝。即使异常规范和catch块中指定的是引用。
引用还有一个重要特性：基类引用可以执行派生类对象
throw bad_1()
###exception类
c++可以把它用作其他异常类的基类，
1.stdexcept异常类
logic_error和runtime_error
2.bad _alloc异常和new
????????????????
###异常、类和继承
???????????????
###异常合适会迷失方向
有两种情况下，会导致问题。
1.如果实在带异常规范的函数中引发的，则必须与规范列表中的某种异常匹配。否则称为意外异常。在默认情况下，这将导致程序异常种植。如果异常不是在函数中引发的，则必须捕获它。
如果没被捕获，则异常被称为未捕获。在默认情况下，这将导致程序
？？？？？？？？？？？？？？？？？？？？？？？？？？？
###有关异常的注意事项
异常规范不适用于模板，因为模板函数引发的异常可能随特定的具体化而异。异常和动态内存分配并非总能协同工作。
##RTTI：运行阶段类型识别
可能包含开关RTTI的编译器设置。RTTI旨在为程序在运行阶段确定对象的类型提供一种标准方式。很多库类已经为其类对象提供了实现了这种功能的方式，但由于c++内部并不支持，因此各个厂商的机制通常互不兼容
rtti的用途
kennel包含不是继承而来的方法，只有某些类型的对象可以使用该方法，也可能是出于调试的目的，想跟踪生产的对象类型。
rtti的工作原理
只能将RTTi用于包含虚函数的类层次结构，原因在于只有对于这种类层次结构，才应该将派生对象的指针赋给基类地址
dynamic_cast运算符将使用一个指向基类的指针来生成一个指向派生类的指针，否则该运算符返回0
typeid运算符返回一个指出对象的类型的值。
type_info结构存储类有关特定类型的信息。
##类型转换运算符
c++更佳严格的限制允许的类型转换，并添加4个类型转换运算符，使得转换过程更加规范：
dynamic_cast
dynamic_cast<type-name>(expression)使得能够在类层次结构中进行向上转换。
const_cast
const_cast<type-name>(expression)指执行一种用途的类型转换，即改变值const或volatile。但修改const值的结果是不确定的。
static_cast

reinterrpret_cast
用于天生危险的类型转换，他不允许删除const，但会执行其他令人生厌的操作，
